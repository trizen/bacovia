#!/usr/bin/ruby

class Power(v, n) {

    method **(Number o) {
        Power(v, n * o)
    }

    method **(Fraction o) {
        Power(v, n * o)
    }

    method **(Object o) {
        Power(self, o)
    }

    method ==(Power o) {
        (v == o.v) &&
        (n == o.n)
    }

    method /(Power o) {
        #~ if (o.v == v) {
            #~ Power(v, n - o.n)
        #~ }
        #~ else {
            #~ Product(self, o.inv)
        #~ }
        Fraction(self, o)
    }

    method /(Object o) {
        #Product(self, o.inv)
        Fraction(self, o)
    }

    method *(Power o) {
        #~ if (o.v == v) {
            #~ Power(v, n + o.n)
        #~ }
        #~ else {
            Product(self, o)
        #~ }
    }

    method *(Object o) {
        Product(self, o)
    }

    method ==(_) {
        false
    }

    method inv {
        Power(v, n.neg)
    }

    method neg {
        Product(-1, self)
    }

    method alternatives {
        gather {
            for a,b in (v.alternatives ~X n.alternatives) {
                take(Exp(Log(a) * b))
                take(Power(a, b))
                take(a ** b)

                # Identity: 1^x = 1
                if (a == 1) {
                    take(1)
                }
            }
        }.uniq_by { .to_s }
    }

    method numeric {
        v.numeric ** n.numeric
    }

    method to_s {
        "Power(#{v}, #{n})"
    }
}
