#!/usr/bin/ruby

class Power(v, n) {

    method **(Object o) {
        Power(v, n * o)
        #Power(self, o)
    }

    method ==(Power o) {
        (v == o.v) &&
        (n == o.n)
    }

    method ==(_) {
        false
    }

    #~ method /(Power o) {
        #~ if (o.v == v) {
            #~ Power(v, n - o.n)
        #~ }
        #~ else {
            #~ Product(self, o.inv)
        #~ }
        #~ Fraction(self, o)
    #~ }

    #~ method *(Power o) {
        #~ if (o.v == v) {
            #~ Power(v, n + o.n)
        #~ }
        #~ else {
            #~ Product(self, o)
        #~ }
    #~ }

    method inv {
        Power(v, n.neg)
    }

    method alternatives {
        gather {
            for a,b in (v.alternatives ~X n.alternatives) {
                take(Exp(Log(a) * b))
                take(Power(a, b))
                take(a ** b)

                # Identity: 1^x = 1
                if (a == 1) {
                    take(1)
                }

                # Identity: log(x)^log(y) = y^(log(log(x)))
                if (a.kind_of(Log) && b.kind_of(Log)) {
                    take(Power(b.v, Log(a)))
                }
            }
        }.uniq_by { .to_s }
    }

    method numeric {
        v.numeric ** n.numeric
    }

    method pretty {
        "#{v.pretty}^#{n.pretty}"
    }

    method to_s {
        "Power(#{v}, #{n})"
    }
}
