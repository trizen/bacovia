#!/usr/bin/ruby

class Fraction(num, den) {

    method +(Number o) {
        self + Fraction(o, 1)
    }

    method +(Fraction o) {
        Fraction(
            num*o.den + o.num*den,
            den*o.den
        )
    }

    method -(Number o) {
        self + o.neg
    }

    method -(Fraction o) {
        self + o.neg
    }

    method -(Object o) {
        Sum(self, o.neg)
    }

    method *(Number o) {
        Fraction(num*o, den)
    }

    method *(Fraction o) {
        Fraction(num*o.num, den*o.den)
    }

    method *(Object o) {
        Product(self, o)
    }

    method /(Number o) {
        Fraction(
            num,
            den * o
        )
    }

    method /(Fraction o) {
        Fraction(
            num * o.den,
            den * o.num,
        )
    }

    method **(Number o) {
        if (o < 0) {
            var a = o.abs
            Fraction(den**a, num**a)
        }
        else {
            Fraction(num**o, den**o)
        }
    }

    method ==(Fraction o) {
        (o.num == num) &&
        (o.den == den)
    }

    method ==(_) {
        false
    }

    method inv {
        if (num == 1) {
            den
        }
        else {
            Fraction(den, num)
        }
    }

    method neg {
        Fraction(num.neg, den)
    }

    method alternatives() is cached {
        gather {
            for a,b in (num.alternatives ~X den.alternatives) {
                take(a/b)
                take(Fraction(a, b))
                #take(Product(a, Exp(Log(b).neg)))

                if (b == 1) {
                    take(a)
                }
            }
        }.uniq_by { .to_s }
    }

    method numeric {
        num.numeric / den.numeric
    }

    method pretty() is cached {
        "(#{num.pretty} / #{den.pretty})"
    }

    method to_s {
        "Fraction(#{num}, #{den})"
    }
}
