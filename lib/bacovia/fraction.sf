#!/usr/bin/ruby

class Fraction(num, den) {

    subset T1 < Difference, Number;

    method +(Fraction y) {
        Fraction(
            (num * y.den) + (den * y.num),
            (den * y.den)
        )
    }

    method +(y < T1) {
        Fraction(
            num + (y * den),
            den
        )
    }

    method -(Fraction y) {
        Fraction(
            (num * y.den) - (den * y.num),
            (den * y.den)
        )
    }

    method -(y < T1) {
        Fraction(
            num - (y * den),
            den
        )
    }

    method *(Fraction y) {
        Fraction(
            num * y.num,
            den * y.den,
        )
    }

    method *(y < T1) {
        Fraction(
            num * y,
            den
        )
    }

    method /(Fraction y) {
        Fraction(
            num * y.den,
            den * y.num
        )
    }

    method /(y < T1) {
        Fraction(
            num,
            den * y
        )
    }

    method inv {
        Fraction(den, num)
    }

    method ==(Fraction o) {
        (o.num == num) &&
        (o.den == den)
    }

    method ==(_) {
        false
    }

    method alternatives() is cached {
        gather {
            for a,b in (num.alternatives ~X den.alternatives) {
                take(a/b)
                take(Fraction(a, b))
                #take(Product(a, Exp(Log(b).neg)))

                if (b == 1) {
                    take(a)
                }

                if (a == 1) {
                    take(b.inv)
                }
            }
        }.uniq_by { .to_s }
    }

    method numeric {
        num.numeric / den.numeric
    }

    method pretty() is cached {
        "(#{num.pretty} / #{den.pretty})"
    }

    method to_s {
        "Fraction(#{num}, #{den})"
    }
}
