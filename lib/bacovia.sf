#!/usr/bin/ruby

# Daniel "Trizen" È˜uteu
# License: GPLv3
# Date: 26 February 2017
# https://github.com/trizen

# A symbolic math library for Sidef.

class Bacovia            {}
class Power    < Bacovia {}
class Fraction < Bacovia {}
class Sum      < Bacovia {}
class Product  < Bacovia {}
class Log      < Bacovia {}
class Exp      < Bacovia {}
class Symbol   < Bacovia {}

include("bacovia/*.sf")

class Bacovia {

    #const I = Exp(Fraction(1, 2) * Log(-1))
    const I = Power(-1, Fraction(1, 2))

    # sin(x) = (exp(i * x) - exp(-i * x)) / (2i)
    method sin {
        Fraction(Exp(I * self) - Exp(-I * self), (2*I))
    }

    # cos(x) = (exp(-i * x) + exp(i * x)) / 2
    method cos {
        Fraction(Exp(-I * self) + Exp(I * self), 2)
    }

    # asin(x) = -i log(i x + sqrt(1 - x^2))
    method asin {
        -I * Log(I*self + Power(1 - Power(self, 2), Fraction(1, 2)))
    }

    # acos(x) = -2 i log(i sqrt((1 - x)/2) + sqrt((1 + x)/2))
    method acos {
        -2*I * Log(I*Power(Fraction(1 - self, 2), Fraction(1, 2)) + Power(Fraction(1 + self, 2), Fraction(1, 2)))
    }

    method +(Object o) {
        Sum(self, o)
    }

    method -(Object o) {
        Sum(self, o.neg)
    }

    method *(Object o) {
        Product(self, o)
        #Fraction(self, o.inv)
    }

    method /(Object o) {
        #Product(self, o.inv)
        Fraction(self, o)
    }

    method neg {
        Product(-1, self)
    }

    method inv {
        Fraction(1, self)
    }

    method **(Object o) {
        Power(self, o)
    }

    method alternatives {
        [self]
    }

    method simplify {
        self.alternatives.min_by { |e|
            e.kind_of(Number) ? -1 : (
                e.kind_of(Complex) ? 0 : e.pretty.len
            )
        }
    }

    method i {
        Product(I, self)
    }
}
